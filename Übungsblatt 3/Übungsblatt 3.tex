
% ----------------------- TODO ---------------------------
% Diese Daten müssen pro Blatt angepasst werden:
\newcommand{\NUMBER}{3}
\newcommand{\EXERCISES}{4}
% Diese Daten müssen einmalig pro Vorlesung angepasst werden:
\newcommand{\COURSE}{Algorithmen}
\newcommand{\TUTOR}{Jan Splett}
\newcommand{\STUDENTA}{Sarah Ertel}
\newcommand{\STUDENTB}{Patrick Greher}
\newcommand{\STUDENTC}{Eugen Ljavin}
\newcommand{\DEADLINE}{10.05.2018}
% ----------------------- TODO ---------------------------

%Template 
\documentclass[a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{geometry,forloop,fancyhdr,fancybox,lastpage}
\geometry{a4paper,left=3cm, right=3cm, top=3cm, bottom=3cm}

%Math
\usepackage{amsmath,amssymb,tabularx}

%Figures
\usepackage{graphicx,tikz,color,float}
\usetikzlibrary{shapes,trees}

%Algorithms
\usepackage[ruled,linesnumbered]{algorithm2e}

%Kopf- und Fußzeile
\pagestyle {fancy}
\fancyhead[L]{Tutor: \TUTOR}
\fancyhead[C]{\COURSE}
\fancyhead[R]{\today}

\fancyfoot[L]{}
\fancyfoot[C]{}
\fancyfoot[R]{Seite \thepage}

%Formatierung der Überschrift, hier nichts ändern
\def\header#1#2{
  \begin{center}
    {\Large\textbf {\"U}bungsblatt #1}\\
    {(Abgabetermin #2)}
  \end{center}
}

%Definition der Punktetabelle, hier nichts ändern
\newcounter{punktelistectr}
\newcounter{punkte}
\newcommand{\punkteliste}[2]{%
  \setcounter{punkte}{#2}%
  \addtocounter{punkte}{-#1}%
  \stepcounter{punkte}%<-- also punkte = m-n+1 = Anzahl Spalten[1]
  \begin{center}%
  \begin{tabularx}{\linewidth}[]{@{}*{\thepunkte}{>{\centering\arraybackslash} X|}@{}>{\centering\arraybackslash}X}
      \forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
      {%
        \thepunktelistectr &
      }
      #2 &  $\Sigma$ \\
      \hline
      \forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
      {%
        &
      } &\\
      \forloop{punktelistectr}{#1}{\value{punktelistectr} < #2 } %
      {%
        &
      } &\\
    \end{tabularx}
  \end{center}
}

\begin{document}

\begin{tabularx}{\linewidth}{m{0.2 \linewidth}X}
  \begin{minipage}{\linewidth}
    \STUDENTA\\
    \STUDENTB\\
    \STUDENTC
  \end{minipage} & \begin{minipage}{\linewidth}
    \punkteliste{1}{\EXERCISES}
  \end{minipage}\\
\end{tabularx}

\header{Nr. \NUMBER}{\DEADLINE}

% ----------------------- TODO ---------------------------
% Hier werden die Aufgaben/Lösungen eingetragen:

\section*{Aufgabe 1}
\subsection*{a)}
\begin{algorithm}[H]
 function insertionSort$(toSort\left[ ~ \right])$ \\
  \For{$i \gets 1; i < toSort.length; i \gets i + 1$}{
			j $\gets$ i\;
			\While{$(j > 0) \wedge (toSort[j - 1] > toSort[j])$}{
				tmp $\gets$ toSort[j - 1]\;
        toSort[j-1] $\gets$ toSort[j]\;
				toSort[j] $\gets$ tmp\;
        j $\gets$ j-1\;
			}     
 }
 \caption{Insertion Sort Algorithmus}
\end{algorithm}

\vspace{1cm}

\begin{algorithm}[H]
 function minimumSwapSort$(toSort\left[ ~ \right])$ \\
  \For{$i \gets 0; i < toSort.length - 1; i \gets i + 1$}{
		\For{$j \gets i + 1; j < toSort.length; i \gets j + 1$}{
			\If{$toSort[i] > toSort[j]$}{
				tmp $\gets$ toSort[i]\;
				toSort[i] $\gets$ toSort[j]\;
				toSort[j] $\gets$ tmp\;
			}
		}	 
  }
 \caption{Minimumsuche $+$ Austausch Algorithmus}
\end{algorithm}

\subsection*{b)}

\subsection*{c)}

\begin{tabular}{l|l|l}
               & Minimumsuche + Austausch Algorithmus & Insertion Sort \\
\hline
Vertauschungen & 0                                    & 0               \\
\hline
Vergleiche     & maximal: $\frac{n^2}{2}-\frac{n}{2}$ & $n-1$            \\
                
\end{tabular}

\subsection*{d)}
$n \in \mathbb{N} $ \\
$A = \left\langle n, n+1, n+2, ... \right\rangle$ \\
Es gibt dann $\frac{n^2}{2}-\frac{n}{2}-(n-1)$ Vergleiche (für beide Algorithmen)

\subsection*{e)}
$n \in \mathbb{N} $ \\
$A = \left\langle n, n-1, n-2, ... \right\rangle$ \\
Es gibt dann $\frac{n^2}{2}-\frac{n}{2}-(n-1)$ Vertauschungen (für beide Algorithmen)


\section*{Aufgabe 2}
$A = \left\langle {4,2,12,10,18,14,6,16,8} \right\rangle$
\subsection*{a)}

\begin{tabular}[t]{ll}
\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {4} 
;\end{tikzpicture}&

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {4} [->]
  child {
		node {2}
	}
;\end{tikzpicture}\\

1) Die erste Zahl aus dem Array nehmen und\\ als Wurzel einsetzen &
2) Die nächste Zahl aus dem Array als Child anfügen\\

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
  child {
		node {4}
	}
;\end{tikzpicture}&

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
	child {
		node {4}
	}
	child{
  		node {12}
	}
;\end{tikzpicture}\\

3) 4 und 2 vertauschen, da $2<4$ &
4) nächste Zahl als Child anfügen\\

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
	child {
		node {4}
			child{
				node{10}
  			}
  			child{
				node{18}
			}
	}
	child{
  		node {12}
  			child{
  				node{14}
  			}
  			child{
  				node{6}
  			}
	}
;\end{tikzpicture}&

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
	child {
		node {4}
			child{
				node{10}
  			}
  			child{
				node{18}
			}
	}
	child{
  		node {6}
  			child{
  				node{14}
  			}
  			child{
  				node{12}
  			}
	}
;\end{tikzpicture}\\

5) Die nächsten vier Elemente werden angefügt\\ (10,18,14 sind größer als die jeweiligen Parent Elemente) &
6) Da $6<12$ müssen die beiden Elemente vertauscht werden\\

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
	child {
		node {4}
			child{
				node{10}
					child{
						node{16}
					}
					child{
						node{8}
					}
  			}
  			child{
				node{18}
			}
	}
	child{
  		node {6}
  			child{
  				node{14}
  			}
  			child{
  				node{12}
  			}
	}
;\end{tikzpicture}&

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts, draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {2} [->]
	child {
		node {4}
			child{
				node{8}
					child{
						node{16}
					}
					child{
						node{10}
					}
  			}
  			child{
				node{18}
			}
	}
	child{
  		node {6}
  			child{
  				node{14}
  			}
  			child{
  				node{12}
  			}
	}
;\end{tikzpicture}\\

6) Die letzten beiden Elemente werden angefügt &
7) 8 und 10 müssen vertrauscht werden

\end{tabular}

\subsection*{b)}

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {4} [->]
  child {
		node {8}
		child {
			node {10}
			child {
				node {16}
			}
		}
		child {
			node {18}
		}
  }
  child {
		node {6}
		child {
			node {14}
		}
		child {
			node {12}
		}
  }
;\end{tikzpicture}

\subsection*{c)}

\begin{tikzpicture}
\tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw]
\tikzstyle{every node}=[bplus]
\tikzstyle{level 1}=[sibling distance=30mm]
\tikzstyle{level 2}=[sibling distance=15mm]
\node {3} [->]
  child {
		node {4}
		child {
			node {8}
			child {
				node {16}
			}
			child {
				node {10}
			}
		}
		child {
			node {18}
		}
  }
  child {
		node {6}
		child {
			node {14}
		}
		child {
			node {12}
		}
  }
;\end{tikzpicture}

\subsection*{d)}

\section*{Aufgabe 3}
\subsection*{a)}

Ein k-Heap kann wie ein Binärer-Heap als Array dargestellt werden.\\
Der Parent node eines Elementes i lässt sich mit  
$\lfloor(i-1)/k \rfloor$, die Child nodes mit $i*k+1 $ bis $i*k+k$ berechnen. 
\subsection*{b)}
Die Höhe eines k-Heaps der Größe n ist $\lfloor log_k(n)+1 \rfloor $
\subsection*{c)}

\begin{algorithm}[H]
 function insertElement(Element e, k-nary k, Heap data)\\
 	positionElement, heapSize $\leftarrow$ heapSize+1\\
 	data[heapSize-1] $\leftarrow$ e\\
 	\For{$parent = \lfloor (positionElement-1)/k \rfloor$, data[positionElement] $>$ parent;}{
 		vertausche (data[positionElement] mit data[parent]
 		positionElement $\leftarrow$ parent
 	}
 	
 \caption{Insert}
\end{algorithm}

\begin{algorithm}[H]
 function ExtractMin(Heap data, k-nary k)\\
  position $\leftarrow$ 0\\
  lösche data[position]\\
  data[position] $\leftarrow$ data[heapSize-1]\\
  \While{true}{
  	children[] $\leftarrow$ data[position*k+1] - data[position*k+k]\\
  	\For{index $\leftarrow$ 0, index $<$ k, index+1}{
  		\If{children[index]$<$data[position]}{
  			vertausche(children[index],data[position])\\
  			position $\leftarrow$ index
  			index $\leftarrow$ k
  		}
  	}
  }
 \caption{ExtractMin}
\end{algorithm}

\section*{Aufgabe 4}
\subsection*{a)}
\subsection*{b)}
Der Algorithmus ruf sich rekursiv drei mal auf und betrachtet dabei $\frac{2}{3}$ der Arraylänge \textbf{n}. Des Weiteren werden zwei Vergleiche durchgeführt, um zu prüfen, ob zwei Elemente getauscht werden müssen sowie für die Abbruchbedingung. Es ergibt sich daraus die Rekursionsvorschrift $T(n) = 3 \cdot T\left(\frac{2}{3} \cdot n\right) + 1$ \\
Mit Hilfe des Mastertheorems lässt sich folgende Komplexität ermitteln:

\begin{align*}
T(n) &= 3 \cdot T\left( \frac{2}{3} \cdot n \right) + 1 \Rightarrow 3 \cdot T\left(\frac{2}{3} \cdot n\right) + \mathcal{O}(1) \\
\text{Nach dem Mastertheorem gilt: } &a = 3; ~ b = \frac{3}{2}; ~ f(n) = 1 = \mathcal{O}(n^c) \text{ mit } c = 0 \\
\text{Es ist: } &c < \log_{\frac{3}{2}} 3 \\
\text{Nach Fall 1 des Mastertheorems gilt: } &T(n) = \mathcal{O}(n^{\log_{\frac{3}{2}} 3}) \approx \mathcal{O}(n^{2,7})
\end{align*}

\subsection*{c)}
Sowohl Quck-Sort, als auch Minimumsuche $+$ Austausch sowie Insertion Sort haben im worst case eine Komplexität von $\mathcal{O}(n^{2})$. \\
Setzt man in dieser Teilaufgabe Komplexität mit Effizienz gleich, gilt $\mathcal{O}(n^{2}) < \mathcal{O}(n^{2,7})$. \\
Damit ist Zwei-Drittel-Sortieren im worst case \textbf{nicht} effizienter als die drei obenstehenden Sortieralgorithmen.


\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
